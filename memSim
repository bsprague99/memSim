#!/usr/bin/env python3
import sys

PAGE_SIZE = 256
OFFSET_MASK = 0x00FF
PAGE_NUM_MASK = 0xFF00

TLB_SIZE = 16 #should actually be 16
BACKING_STORE = "BACKING_STORE.bin"
BACKING_STORE_SIZE = 65536
BACKING_STORE_PAGE_SIZE = 256

TLBUFF = [] # containing vals representing [page_num, frame_num]

PAGE_TABLE = [None] * PAGE_SIZE

PHYSICAL_MEMORY_SIZE = PAGE_SIZE

#Define a dictionary to store each page table entry
entry = {'present': False, 'frame': None}
# Populate the page table with empty entries

#initializing states for FSM
START = 0
TLB = 1
PTABLE = 2
BSTOR = 3
END = 4

def memSim(rsf_name, frames, pra):
    # inputs:
    #   rsf_name = name of a file containing the list of logical memory addresses
    #   frames = integeger 0 < and <= 256 representing the number of frames in the system
    #   pra = page replacement algorithm - first-in first-out (FIFO), least recently used (LRU), optimal (OPT)
    # physical memory of size frames * 256 bytes
    memory_size = PAGE_SIZE * frames

    #initialize the physical memory to all zeros
    physical_memory = bytearray(memory_size)

    #read the rsf to get  a list of address objects formatted [logical_addr, page_num, offset]
    addrs = read_rsf(rsf_name)
    back_store = open(BACKING_STORE, "rb")
    
    # Initilize PAGE_TABLE as a list of dicts that contain the frame num and a'present' bit
    for i in range(PAGE_SIZE):
        PAGE_TABLE[i] = entry.copy()
        
    #counters to keep track of tlb hits, tlb misses, and page faults for metrics
    tlb_hit_count = 0
    tlb_miss_count = 0
    page_fault_count = 0
    total_addrs = len(addrs)

    tlb_count = 0 #number of pages in the tlb
    frame_num = 0 #index for physical memory
    frame_count = 0 #keep track of number of frames

    for addr in addrs: #loop through all the addresses in the list of addresses
        #implementing a finite state machine to look for page
        state = START
        #current address, page number, and offset
        curr_addr = addr[0]
        curr_page_num = addr[2]
        curr_offset = addr[1]
        found_flag = False #flag to check if the page has been found or nah

        while(state != END):
            if state == START:
                #do something & move to next state
                #print("in start %d" % curr_addr)
                state = TLB
            #first check the tlb for the page
            elif state == TLB:
                #check if the page is in the tlb, if it is, yay, if not, check page table for page
                #print("in tlb %d" % curr_addr)
                found_flag, curr_frame_num = check_tlb(curr_page_num)
                if(found_flag):
                    tlb_hit_count += 1
                    #page is located in tlb yay, pull page data from physical memory using the frame number
                    page_data = physical_memory[curr_frame_num * PAGE_SIZE:(curr_frame_num * PAGE_SIZE + PAGE_SIZE)]
                    ref_byte = physical_memory[curr_frame_num * PAGE_SIZE + curr_offset: curr_frame_num * PAGE_SIZE + curr_offset + 1]
                    state = END
                else:
                    tlb_miss_count += 1
                    state = PTABLE
            #next check the page table for the page
            elif state == PTABLE:
                #check if the page is in the page table, if it is, yay, if not, retrieve page from backing store
                found_flag, curr_frame_num = check_ptable(curr_page_num)
                if(found_flag):
                    #page is located in p_table yay, pull page data from physical memory using the frame number
                    page_data = physical_memory[curr_frame_num * PAGE_SIZE:(curr_frame_num * PAGE_SIZE + PAGE_SIZE)]
                    ref_byte = physical_memory[curr_frame_num * PAGE_SIZE + curr_offset: curr_frame_num * PAGE_SIZE + curr_offset + 1]
                    state = END
                else:
                    #page fault occured, get page from backing store
                    page_fault_count += 1
                    state = BSTOR
            #if it table look up fails, check the backing store memory to retrieve page
            elif state == BSTOR:
                #get page data from the backing store
                page_data = get_page(curr_page_num, curr_offset)
                if(pra.upper() == "LRU"):
                    curr_frame_num, ref_byte = run_lru()
                elif(pra.upper() == "OPT"):
                    curr_frame_num, ref_byte = run_opt()
                else:
                    #by default, run FIFO
                    curr_frame_num, ref_byte, frame_count, frame_num, tlb_count = run_fifo(page_data, physical_memory, curr_page_num, curr_offset, frame_num, frame_count, frames, tlb_count)

                state = END
        #end state - FSM completed
        #convert reference byte to int
        ref_byte_int = int.from_bytes(ref_byte, 'little', signed=True)
        #print metrics for each logical address
        print_addr(curr_addr, ref_byte_int, curr_frame_num, page_data.hex().upper())

    #completed program, print metrics
    print_metrics(total_addrs, tlb_hit_count, tlb_miss_count, page_fault_count)
    return

#function to update values in the tlb
def update_tlb(tlb_count, curr_page_num, curr_frame_num):
    #add current page to TLB
    if(tlb_count >= TLB_SIZE):
        #tlb is full
        #FIFO - remove value, add current value to the tail of the queue
        TLBUFF.pop(0)
        TLBUFF.append([curr_page_num, curr_frame_num])
        #tlb remains full
        tlb_count = TLB_SIZE
    else:
        #print("TLB has space")
        #tlb has space, add vals to the tail of the queue
        TLBUFF.append([curr_page_num, curr_frame_num])
        tlb_count += 1
    return tlb_count
    
#function to run fifo replacement algorithm
def run_fifo(page_data, physical_memory, curr_page_num, curr_offset, frame_num, frame_count, frames, tlb_count):
    #load into physical memory
    physical_memory[frame_num * PAGE_SIZE:(frame_num * PAGE_SIZE + PAGE_SIZE)] = page_data
    ref_byte = page_data[curr_offset: curr_offset + 1]

    #update page table
    #must map frame num to page num in the page table
    if(frame_count >= frames):
        #print("\n replacing frame !! \n")
        #physical memory full, upate page
        #search page table to find the value that was originally set to frame_num & remove it from page table
        for page in PAGE_TABLE:
            if page['frame'] == frame_num:
                page['present'] = False
                page['frame'] = None
        #update page table to map page_num to the updated frame num
        PAGE_TABLE[curr_page_num]['present'] = True
        PAGE_TABLE[curr_page_num]['frame'] = frame_num

        #update TLB table to map page_num to the updated frame num
        #print(TLBUFF)
        for page in TLBUFF:
            #print("we get stuck?")
            #print("frame num? %d" % page[1])
            if(page[1] == frame_num):
                TLBUFF.remove(page)
        #physical memory remains full
        frame_count = frames
    else:
        #print("PAGE FAULT !!")
        PAGE_TABLE[curr_page_num]['present'] = True
        PAGE_TABLE[curr_page_num]['frame'] = frame_num

        frame_count += 1

    tlb_count = update_tlb(tlb_count, curr_page_num, frame_num)
    #return current frame_num before incrementing
    curr_frame_num = frame_num
    #increment frame number for next address
    frame_num = (frame_num + 1) % frames

    return curr_frame_num, ref_byte, frame_count, frame_num, tlb_count

#function to run lru replacement algorithm
def run_lru():
    curr_frame_num = 0
    ref_byte = 0
    return curr_frame_num, ref_byte

#function to run optimal replacement algorithm
def run_opt():
    curr_frame_num = 0
    ref_byte = 0
    return curr_frame_num, ref_byte

#function to check if page is in tlb
def check_tlb(page_num):
    #TLBUFF is a list containing vals representing [page_num, frame_num]
    for i, val in enumerate(TLBUFF):
        # print(val)
        if(val and val[0] == page_num):
            #tlb is populated and contains the desired page number
            #move entry to the end of TLB
            TLBUFF.pop(i)
            TLBUFF.append([page_num, val[1]])
            return True, val[1]
    return False, 0

#function to check if page is in ptable
def check_ptable(page_num):
    # Check if the given page number is in the page table
    if PAGE_TABLE[page_num] is not None and PAGE_TABLE[page_num]['present'] is True:
        # If page is present, return the corresponding frame number
        return True, PAGE_TABLE[page_num]['frame']
    # If page is not present, return False
    return False, 0

#function to get page from backing store file
def get_page(page_num, page_offset):
   with open(BACKING_STORE, "rb") as back_store:
        # Calculate the offset in the backing store file
        offset = page_num * PAGE_SIZE
        # Seek to the correct offset
        back_store.seek(offset)
        # Read a page (256 bytes) from the file and return it
        page_data = back_store.read(PAGE_SIZE)
        #ref_byte = getRefBit(back_store, page_num, page_offset)
        return page_data
   
#function to get reference byte
def getRefBit(backing_store, page_num, offset): 
    #find the reference byte in the backing store
    backing_store.seek((page_num * PAGE_SIZE) + offset, 0)
    #read in 1 byte value
    ref_byte = backing_store.read(1)
    #convert from byte to integer
    ref_byte_int = int.from_bytes(ref_byte, 'little', signed=True)
    return ref_byte_int

#function to print the address values for output
def print_addr(addr, ref_byte, mem_frame_num, content):
    # For every address in the given addresses file, print one line of comma-separated fields, consisting of:
    # - The full address (from the reference file) 
    # - The value of the byte referenced (1 signed integer) 
    # - The physical memory frame number (one positive integer) 
    # - The content of the entire frame (256 bytes in hex ASCII characters, no spaces in between) 
    # - new line character 
    print("%d, %d, %d, %s" % (addr, ref_byte, mem_frame_num, content))
    return

#function to calculate and print the metrics values for output
def print_metrics(total_addrs, tlb_hit_count, tlb_miss_count, page_fault_count):
    # printed to standard out:
    #   - Total number of translated addresses
    #   - Total number of page faults and a % page fault rate 
    #   - Total number of TLB hits, misses and % TLB hit rate 
    print("Number of Translated Addresses = %d" % total_addrs)
    print("Page Faults = %d" % page_fault_count)
    print("Page Fault Rate = %3.3f" % (page_fault_count / total_addrs))
    print("TLB Hits = %d" % tlb_hit_count)
    print("TLB Misses = %d" % tlb_miss_count)
    print("TLB Hit Rate = %3.3f" % (tlb_hit_count / total_addrs))
    return

#function to read in addresses from the reference sequence file
def read_rsf(rsf_name):
    #list to store in values from rsf
    addrs = []

    o_file = open(file_name, "rt")
    for line in o_file:
        #read addresses in from open file 
        #get logical address
        addr = int(line)
        #get offset by bit masking LSB 0-7
        # 0000 0000 1111 1111 -> mask = 0x00FF
        offset = addr & OFFSET_MASK
        #get page num LSB 8-15
        # 1111 1111 0000 0000 -> mask = 0xFF00 132
        page_num = addr & PAGE_NUM_MASK
        page_num = page_num >> 8 #shift value to get rid of trailing zeroes
        #append address object to list of addresses
        addrs.append([addr, offset, page_num])
    return addrs

if __name__ == '__main__':
    #usage of executable ./memSim <reference-sequence-file.txt> <FRAMES> <PRA>
    file_name = sys.argv[1]
    frames = 256
    pra = "FIFO"
    frame_flag = pra_flag = 0

    if(len(sys.argv) > 2):
        #more than jus file_name provided
        if(len(sys.argv) == 3):
            frame_flag = 1
            pra_flag = 0
        if(len(sys.argv) == 4):
            frame_flag = 1
            pra_flag = 1

    if(frame_flag == 1):
        #frame provided
        if(0 < int(sys.argv[2]) and int(sys.argv[2]) <= 256):
            #number of frames valid, set frames
            frames = int(sys.argv[2])
    if(pra_flag == 1):
        #algorithm provided
        if(sys.argv[3] == "FIFO" or sys.argv[3] == "LRU" or sys.argv[3] == "OPT"):
            #algorithm valid, set pra
            pra = sys.argv[3]

    #call function with correct arguments
    memSim(file_name, frames, pra)
