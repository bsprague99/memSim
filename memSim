#!/usr/bin/env python3
import sys

PAGE_SIZE = 256
OFFSET_MASK = 0x00FF
PAGE_NUM_MASK = 0xFF00

TLB_SIZE = 16
BACKING_STORE = "BACKING_STORE.bin"
BACKING_STORE_SIZE = 65536
BACKING_STORE_PAGE_SIZE = 256

TLB_PAGE_NUM = [(None)] * TLB_SIZE
TLB_FRAME_NUM = [(None)] * TLB_SIZE

PAGE_TABLE = [(None)] * PAGE_SIZE

#Define a dictionary to store each page table entry
entry = {'present': False, 'frame': None}
# Populate the page table with empty entries

#initializing states for FSM
START = 0
TLB = 1
PTABLE = 2
BSTOR = 3
END = 4

def memSim(rsf_name, frames, pra):
    #inputs:
    #   rsf_name = name of a file containing the list of logical memory addresses
    #   frames = integeger 0 < and <= 256 representing the number of frames in the system
    #   pra = page replacement algorithm - first-in first-out (FIFO), least recently used (LRU), optimal (OPT)
    memory_size = PAGE_SIZE * frames
    #read the rsf to get  a list of address objects formatted [logical_addr, page_num, offset]
    addrs = read_rsf(rsf_name)
    back_store = open(BACKING_STORE, "rb")
    
    # Initilize PAGE_TABLE as a list of dicts that contain the frame num and a'present' bit
    for i in range(PAGE_SIZE):
        PAGE_TABLE[i] = entry.copy()
        
        

    #counters to keep track of tlb hits, tlb misses, and page faults for metrics
    tlb_hit_count = 0
    tlb_miss_count = 0
    page_fault_count = 0
    total_addrs = len(addrs)

    for addr in addrs: #loop through all the addresses in the list of addresses
        #implementing a finite state machine to look for page
        state = START
        found = False
        while(state != END):
            if state == START:
                #do something & move to next state
                state = TLB
            #first check the tlb for the page
            elif state == TLB:
                #check if the page is in the tlb, if it is, yay, if not, check page table for page
                found = check_tlb()
                if(found):
                    tlb_hit_count += 1
                    state = END
                else:
                    tlb_miss_count += 1
                    state = PTABLE
            #next check the page table for the page
            elif state == PTABLE:
                #check if the page is in the page table, if it is, yay, if not, retrieve page from backing store
                found = check_ptable(addr[2])
                if(found):
                    state = END
                else:
                    page_fault_count += 1
                    state = BSTOR
            #if it table look up fails, check the backing store memory to retrieve page
            elif state == BSTOR:
                get_page(back_store)
                state = END
        #end state - FSM completed, print address metrics
        #print_addr(addr, ref_byte, mem_frame_num, content) #uncomment once vals are determined
        print_addr(addr, 0, 0, "content")
    #completed program, print metrics
    print_metrics(total_addrs, tlb_hit_count, tlb_miss_count, page_fault_count)
    return

#function to check if page is in tlb
def check_tlb():
    found = True
    return found

#function to check if page is in ptable
def check_ptable(page_num):
    # Check if the given page number is in the page table
    if PAGE_TABLE[page_num] is not None and PAGE_TABLE[page_num]['present']:
        # If page is present, update the TLB and return the corresponding frame number
        # If page is not present, return False
        found = False
    return found

#function to get page from backing store file
def get_page(back_store, page_num):
    # Calculate the offset in the backing store file
    offset = page_num * PAGE_SIZE
    # Open the backing store file and seek to the correct offset
    with back_store as f:
        f.seek(offset)
        # Read a page (256 bytes) from the file and return it
        page_data = f.read(PAGE_SIZE)
        return page_data

#function to print the address values for output
def print_addr(addr, ref_byte, mem_frame_num, content):
    # For every address in the given addresses file, print one line of comma-separated fields, consisting of:
    # - The full address (from the reference file) 
    # - The value of the byte referenced (1 signed integer) 
    # - The physical memory frame number (one positive integer) 
    # - The content of the entire frame (256 bytes in hex ASCII characters, no spaces in between) 
    # - new line character 
    print("%d, %d, %d, %s" % (addr[0], ref_byte, mem_frame_num, content))
    return

#function to calculate and print the metrics values for output
def print_metrics(total_addrs, tlb_hit_count, tlb_miss_count, page_fault_count):
    # printed to standard out:
    #   - Total number of translated addresses
    #   - Total number of page faults and a % page fault rate 
    #   - Total number of TLB hits, misses and % TLB hit rate 
    print("Number of Translated Addresses = %d" % total_addrs)
    print("Page Faults = %d" % page_fault_count)
    print("Page Fault Rate = %3.3f" % (page_fault_count / total_addrs))
    print("TLB Hits = %d" % tlb_hit_count)
    print("TLB Misses = %d" % tlb_miss_count)
    print("TLB Hit Rate = %3.3f" % (tlb_hit_count / total_addrs))
    return

#function to read in addresses from the reference sequence file
def read_rsf(rsf_name):
    #list to store in values from rsf
    addrs = []

    o_file = open(file_name, "rt")
    for line in o_file:
        #read addresses in from open file 
        #get logical address
        addr = int(line)
        #get offset by bit masking LSB 0-7
        # 0000 0000 1111 1111 -> mask = 0x00FF
        offset = addr & OFFSET_MASK
        #get page num LSB 8-15
        # 1111 1111 0000 0000 -> mask = 0xFF00
        page_num = addr & PAGE_NUM_MASK
        #append address object to list of addresses
        addrs.append([addr, offset, page_num])
    return addrs

if __name__ == '__main__':
    #usage of executable ./memSim <reference-sequence-file.txt> <FRAMES> <PRA>
    file_name = sys.argv[1]
    frames = 256
    pra = "FIFO"
    frame_flag = pra_flag = 0

    if(len(sys.argv) > 2):
        #more than jus file_name provided
        if(len(sys.argv) == 3):
            frame_flag = 1
            pra_flag = 0
        if(len(sys.argv) == 4):
            frame_flag = 1
            pra_flag = 1

    if(frame_flag == 1):
        #frame provided
        if(0 < int(sys.argv[2]) and int(sys.argv[2]) <= 256):
            #number of frames valid, set frames
            frames = int(sys.argv[2])
    if(pra_flag == 1):
        #algorithm provided
        if(sys.argv[3] == "FIFO" or sys.argv[3] == "LRU" or sys.argv[3] == "OPT"):
            #algorithm valid, set pra
            pra = sys.argv[3]
    #call function with correct arguments
    memSim(file_name, frames, pra)
